{"ast":null,"code":"import _toConsumableArray from \"C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useEffect, useCallback, useMemo } from 'react';\n\nvar getEventKey = function getEventKey(m) {\n  return \"\".concat(m.transactionHash, \"_\").concat(m.logIndex);\n};\n/**\r\n * Enables you to keep track of events\r\n *\r\n * ~ Features ~\r\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\r\n  - Specify the name of the contract, in this case it is \"YourContract\"\r\n  - Specify the name of the event in the contract, in this case we keep track of \"SetPurpose\" event\r\n  - Specify the provider\r\n * @param contracts (Record<string, Contract>) :: record of current contractname/contract\r\n * @param contractName (string) :: name of the contract you are interested in\r\n * @param eventName (string) :: name of the event\r\n * @param provider (TEthersProvider)\r\n * @param startBlock (number) string block of events\r\n * @returns (ethers->Event)\r\n */\n\n\nexport var useEventListener = function useEventListener(contracts, contractName, eventName, provider, startBlock) {\n  var _useState = useState(new Map()),\n      _useState2 = _slicedToArray(_useState, 2),\n      eventMap = _useState2[0],\n      setEventMap = _useState2[1];\n\n  var deps = JSON.stringify(_toConsumableArray(eventMap));\n  var events = useMemo(function () {\n    return _toConsumableArray(eventMap).map(function (m) {\n      return m[1];\n    });\n  }, [deps]);\n  var addNewEvent = useCallback(function () {\n    for (var _len = arguments.length, listenerArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      listenerArgs[_key] = arguments[_key];\n    }\n\n    if (listenerArgs != null && listenerArgs.length > 0) {\n      var newEvent = listenerArgs[listenerArgs.length - 1];\n\n      if (newEvent.event != null && newEvent.logIndex != null && newEvent.transactionHash != null) {\n        var newMap = new Map([[getEventKey(newEvent), newEvent]]);\n        setEventMap(function (oldMap) {\n          return new Map([].concat(_toConsumableArray(oldMap), _toConsumableArray(newMap)));\n        });\n      }\n    }\n  }, [setEventMap]);\n  useEffect(function () {\n    if (provider) {\n      // if you want to read _all_ events from your contracts, set this to the block number it is deployed\n      provider.resetEventsBlock(startBlock);\n    }\n\n    if ((contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null) {\n      try {\n        contracts[contractName].on(eventName, addNewEvent);\n        return function () {\n          contracts[contractName].off(eventName, addNewEvent);\n        };\n      } catch (e) {\n        console.log(e);\n      }\n    }\n  }, [provider, startBlock, contracts, contractName, eventName, addNewEvent]);\n  return events;\n};","map":{"version":3,"sources":["C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/eth-hooks/events/useEventListener.js"],"names":["useState","useEffect","useCallback","useMemo","getEventKey","m","transactionHash","logIndex","useEventListener","contracts","contractName","eventName","provider","startBlock","Map","eventMap","setEventMap","deps","JSON","stringify","events","map","addNewEvent","listenerArgs","length","newEvent","event","newMap","oldMap","resetEventsBlock","on","off","e","console","log"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,WAA9B,EAA2CC,OAA3C,QAA0D,OAA1D;;AACA,IAAMC,WAAW,GAAG,SAAdA,WAAc,CAACC,CAAD,EAAO;AACvB,mBAAUA,CAAC,CAACC,eAAZ,cAA+BD,CAAC,CAACE,QAAjC;AACH,CAFD;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,OAAO,IAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB,CAACC,SAAD,EAAYC,YAAZ,EAA0BC,SAA1B,EAAqCC,QAArC,EAA+CC,UAA/C,EAA8D;AAC1F,kBAAgCb,QAAQ,CAAC,IAAIc,GAAJ,EAAD,CAAxC;AAAA;AAAA,MAAOC,QAAP;AAAA,MAAiBC,WAAjB;;AACA,MAAMC,IAAI,GAAGC,IAAI,CAACC,SAAL,oBAAmBJ,QAAnB,EAAb;AACA,MAAMK,MAAM,GAAGjB,OAAO,CAAC;AAAA,WAAM,mBAAIY,QAAJ,EAAcM,GAAd,CAAkB,UAAChB,CAAD;AAAA,aAAOA,CAAC,CAAC,CAAD,CAAR;AAAA,KAAlB,CAAN;AAAA,GAAD,EAAuC,CAACY,IAAD,CAAvC,CAAtB;AACA,MAAMK,WAAW,GAAGpB,WAAW,CAAC,YAAqB;AAAA,sCAAjBqB,YAAiB;AAAjBA,MAAAA,YAAiB;AAAA;;AACjD,QAAIA,YAAY,IAAI,IAAhB,IAAwBA,YAAY,CAACC,MAAb,GAAsB,CAAlD,EAAqD;AACjD,UAAMC,QAAQ,GAAGF,YAAY,CAACA,YAAY,CAACC,MAAb,GAAsB,CAAvB,CAA7B;;AACA,UAAIC,QAAQ,CAACC,KAAT,IAAkB,IAAlB,IAA0BD,QAAQ,CAAClB,QAAT,IAAqB,IAA/C,IAAuDkB,QAAQ,CAACnB,eAAT,IAA4B,IAAvF,EAA6F;AACzF,YAAMqB,MAAM,GAAG,IAAIb,GAAJ,CAAQ,CAAC,CAACV,WAAW,CAACqB,QAAD,CAAZ,EAAwBA,QAAxB,CAAD,CAAR,CAAf;AACAT,QAAAA,WAAW,CAAC,UAACY,MAAD;AAAA,iBAAY,IAAId,GAAJ,8BAAYc,MAAZ,sBAAuBD,MAAvB,GAAZ;AAAA,SAAD,CAAX;AACH;AACJ;AACJ,GAR8B,EAQ5B,CAACX,WAAD,CAR4B,CAA/B;AASAf,EAAAA,SAAS,CAAC,YAAM;AACZ,QAAIW,QAAJ,EAAc;AACV;AACAA,MAAAA,QAAQ,CAACiB,gBAAT,CAA0BhB,UAA1B;AACH;;AACD,QAAI,CAACJ,SAAS,KAAK,IAAd,IAAsBA,SAAS,KAAK,KAAK,CAAzC,GAA6C,KAAK,CAAlD,GAAsDA,SAAS,CAACC,YAAD,CAAhE,KAAmF,IAAvF,EAA6F;AACzF,UAAI;AACAD,QAAAA,SAAS,CAACC,YAAD,CAAT,CAAwBoB,EAAxB,CAA2BnB,SAA3B,EAAsCW,WAAtC;AACA,eAAO,YAAM;AACTb,UAAAA,SAAS,CAACC,YAAD,CAAT,CAAwBqB,GAAxB,CAA4BpB,SAA5B,EAAuCW,WAAvC;AACH,SAFD;AAGH,OALD,CAMA,OAAOU,CAAP,EAAU;AACNC,QAAAA,OAAO,CAACC,GAAR,CAAYF,CAAZ;AACH;AACJ;AACJ,GAhBQ,EAgBN,CAACpB,QAAD,EAAWC,UAAX,EAAuBJ,SAAvB,EAAkCC,YAAlC,EAAgDC,SAAhD,EAA2DW,WAA3D,CAhBM,CAAT;AAiBA,SAAOF,MAAP;AACH,CA/BM","sourcesContent":["import { useState, useEffect, useCallback, useMemo } from 'react';\r\nconst getEventKey = (m) => {\r\n    return `${m.transactionHash}_${m.logIndex}`;\r\n};\r\n/**\r\n * Enables you to keep track of events\r\n *\r\n * ~ Features ~\r\n  - Provide readContracts by loading contracts (see more on ContractLoader.js)\r\n  - Specify the name of the contract, in this case it is \"YourContract\"\r\n  - Specify the name of the event in the contract, in this case we keep track of \"SetPurpose\" event\r\n  - Specify the provider\r\n * @param contracts (Record<string, Contract>) :: record of current contractname/contract\r\n * @param contractName (string) :: name of the contract you are interested in\r\n * @param eventName (string) :: name of the event\r\n * @param provider (TEthersProvider)\r\n * @param startBlock (number) string block of events\r\n * @returns (ethers->Event)\r\n */\r\nexport const useEventListener = (contracts, contractName, eventName, provider, startBlock) => {\r\n    const [eventMap, setEventMap] = useState(new Map());\r\n    const deps = JSON.stringify([...eventMap]);\r\n    const events = useMemo(() => [...eventMap].map((m) => m[1]), [deps]);\r\n    const addNewEvent = useCallback((...listenerArgs) => {\r\n        if (listenerArgs != null && listenerArgs.length > 0) {\r\n            const newEvent = listenerArgs[listenerArgs.length - 1];\r\n            if (newEvent.event != null && newEvent.logIndex != null && newEvent.transactionHash != null) {\r\n                const newMap = new Map([[getEventKey(newEvent), newEvent]]);\r\n                setEventMap((oldMap) => new Map([...oldMap, ...newMap]));\r\n            }\r\n        }\r\n    }, [setEventMap]);\r\n    useEffect(() => {\r\n        if (provider) {\r\n            // if you want to read _all_ events from your contracts, set this to the block number it is deployed\r\n            provider.resetEventsBlock(startBlock);\r\n        }\r\n        if ((contracts === null || contracts === void 0 ? void 0 : contracts[contractName]) != null) {\r\n            try {\r\n                contracts[contractName].on(eventName, addNewEvent);\r\n                return () => {\r\n                    contracts[contractName].off(eventName, addNewEvent);\r\n                };\r\n            }\r\n            catch (e) {\r\n                console.log(e);\r\n            }\r\n        }\r\n    }, [provider, startBlock, contracts, contractName, eventName, addNewEvent]);\r\n    return events;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}