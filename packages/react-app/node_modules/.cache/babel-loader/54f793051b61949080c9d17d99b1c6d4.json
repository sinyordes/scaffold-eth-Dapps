{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { BigNumber } from 'ethers';\nimport { useState, useCallback } from 'react';\nimport { useOnRepetition } from \"./useOnRepetition\";\nvar zero = BigNumber.from(0);\n/**\r\n * Gets your balance in ETH from given address and provider\r\n *\r\n * ~ Features ~\r\n  - Provide address and get balance corresponding to given address\r\n  - Change provider to access balance on different chains (ex. mainnetProvider)\r\n  - If no pollTime is passed, the balance will update on every new block\r\n * @param provider (ethers->Provider)\r\n * @param address (string)\r\n * @param pollTime (number) :: if >0 use polling, else use instead of onBlock event\r\n * @returns (Bignumber) ::  current balance\r\n */\n\nexport var useBalance = function useBalance(provider, address) {\n  var pollTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n  var _useState = useState(),\n      _useState2 = _slicedToArray(_useState, 2),\n      balance = _useState2[0],\n      setBalance = _useState2[1];\n\n  var pollBalance = useCallback( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(provider, address) {\n      var newBalance;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(provider && address)) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 3;\n              return provider.getBalance(address);\n\n            case 3:\n              newBalance = _context.sent;\n\n              if (!newBalance.eq(balance !== null && balance !== void 0 ? balance : zero)) {\n                setBalance(newBalance);\n                console.log(address, newBalance.toString(), balance);\n              }\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(), [balance]);\n  useOnRepetition(pollBalance, {\n    pollTime: pollTime,\n    provider: provider,\n    leadingTrigger: address != null && address !== '' && provider != null\n  }, provider, address);\n  return balance !== null && balance !== void 0 ? balance : zero;\n};","map":{"version":3,"sources":["C:/Users/batuhansen/Desktop/eth/challenge-1-decentralized-staking/node_modules/eth-hooks/useBalance.js"],"names":["BigNumber","useState","useCallback","useOnRepetition","zero","from","useBalance","provider","address","pollTime","balance","setBalance","pollBalance","getBalance","newBalance","eq","console","log","toString","leadingTrigger"],"mappings":";;;AAAA,SAASA,SAAT,QAA0B,QAA1B;AACA,SAASC,QAAT,EAAmBC,WAAnB,QAAsC,OAAtC;AACA,SAASC,eAAT,QAAgC,mBAAhC;AACA,IAAMC,IAAI,GAAGJ,SAAS,CAACK,IAAV,CAAe,CAAf,CAAb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACC,QAAD,EAAWC,OAAX,EAAqC;AAAA,MAAjBC,QAAiB,uEAAN,CAAM;;AAC3D,kBAA8BR,QAAQ,EAAtC;AAAA;AAAA,MAAOS,OAAP;AAAA,MAAgBC,UAAhB;;AACA,MAAMC,WAAW,GAAGV,WAAW;AAAA,wEAAC,iBAAOK,QAAP,EAAiBC,OAAjB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBACxBD,QAAQ,IAAIC,OADY;AAAA;AAAA;AAAA;;AAAA;AAAA,qBAECD,QAAQ,CAACM,UAAT,CAAoBL,OAApB,CAFD;;AAAA;AAElBM,cAAAA,UAFkB;;AAGxB,kBAAI,CAACA,UAAU,CAACC,EAAX,CAAcL,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmDN,IAAjE,CAAL,EAA6E;AACzEO,gBAAAA,UAAU,CAACG,UAAD,CAAV;AACAE,gBAAAA,OAAO,CAACC,GAAR,CAAYT,OAAZ,EAAqBM,UAAU,CAACI,QAAX,EAArB,EAA4CR,OAA5C;AACH;;AANuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAD;;AAAA;AAAA;AAAA;AAAA,OAQ5B,CAACA,OAAD,CAR4B,CAA/B;AASAP,EAAAA,eAAe,CAACS,WAAD,EAAc;AAAEH,IAAAA,QAAQ,EAARA,QAAF;AAAYF,IAAAA,QAAQ,EAARA,QAAZ;AAAsBY,IAAAA,cAAc,EAAEX,OAAO,IAAI,IAAX,IAAmBA,OAAO,KAAK,EAA/B,IAAqCD,QAAQ,IAAI;AAAvF,GAAd,EAA6GA,QAA7G,EAAuHC,OAAvH,CAAf;AACA,SAAOE,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,KAAK,CAArC,GAAyCA,OAAzC,GAAmDN,IAA1D;AACH,CAbM","sourcesContent":["import { BigNumber } from 'ethers';\r\nimport { useState, useCallback } from 'react';\r\nimport { useOnRepetition } from \"./useOnRepetition\";\r\nconst zero = BigNumber.from(0);\r\n/**\r\n * Gets your balance in ETH from given address and provider\r\n *\r\n * ~ Features ~\r\n  - Provide address and get balance corresponding to given address\r\n  - Change provider to access balance on different chains (ex. mainnetProvider)\r\n  - If no pollTime is passed, the balance will update on every new block\r\n * @param provider (ethers->Provider)\r\n * @param address (string)\r\n * @param pollTime (number) :: if >0 use polling, else use instead of onBlock event\r\n * @returns (Bignumber) ::  current balance\r\n */\r\nexport const useBalance = (provider, address, pollTime = 0) => {\r\n    const [balance, setBalance] = useState();\r\n    const pollBalance = useCallback(async (provider, address) => {\r\n        if (provider && address) {\r\n            const newBalance = await provider.getBalance(address);\r\n            if (!newBalance.eq(balance !== null && balance !== void 0 ? balance : zero)) {\r\n                setBalance(newBalance);\r\n                console.log(address, newBalance.toString(), balance);\r\n            }\r\n        }\r\n    }, [balance]);\r\n    useOnRepetition(pollBalance, { pollTime, provider, leadingTrigger: address != null && address !== '' && provider != null }, provider, address);\r\n    return balance !== null && balance !== void 0 ? balance : zero;\r\n};\r\n"]},"metadata":{},"sourceType":"module"}